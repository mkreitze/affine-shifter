import numpy as np
import itertools as it
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator

# Global params

WINDOWSIZE = 3
ALPHABET = [0,1]
VERBOSE = True
# params generated by global params, are unchanging

ALPHABETSIZE = len(ALPHABET)
MAXSIZE = ALPHABETSIZE**WINDOWSIZE
aNums = 2 # {1,|A|-1} (non zeros)
cNums = 1 # = (1 - sum(c_i - a1)) mod (|A|)
bNums = WINDOWSIZE - 2 # {0, |A|-1} (generics)




def makeGenShift(windowSize = WINDOWSIZE):
    genShift = np.eye(windowSize+1)
    genShift = np.roll(genShift,1,axis=1)
    genShift[-1] = 0
    genShift[-1,-1] = 1
    return(genShift)

def calcC(a1,bs,alphabetSize = ALPHABETSIZE):
    c = (1 - np.sum(bs) - a1)%alphabetSize
    return(c)

def checkCycle(shiftedWindow,shifter,alphabetSize = ALPHABETSIZE,maxSize = MAXSIZE):
    if VERBOSE:
        print("Shifts on 0 window")

    original = np.copy(shiftedWindow)
    i = 0 
    while True:
        if VERBOSE:
            print(shiftedWindow)
        shiftedWindow = (shifter@shiftedWindow)%alphabetSize
        i += 1
        if np.array_equal(original,shiftedWindow) or i == maxSize:
            break
    return(i)

def plotPows(pows,name,factors,alphabetSize):
    figR = plt.figure().gca()
    ys = [] 
    xs = list(range(MAXSIZE))
    # xTicks = np.append(fig.get_xticks(),factors)
    for powerQuant in pows:
        ys.append(len(powerQuant))
    figR.xaxis.set_major_locator(MaxNLocator(integer = True)) # forces axis to be integers
    bars = plt.bar(xs,ys,color = 'orange', width = 0.4)
    for fact in factors:
        bars[fact].set_color('red')
        height = bars[fact].get_height()
        figR.text( bars[fact].get_x() + bars[fact].get_width() / 2, height, f"{fact}", ha="center", va="bottom")
    plt.title(f"Distribution of {name} powers for |A| = {alphabetSize}")
    plt.savefig(f'Power Dist of {name} for A = {alphabetSize}',dpi = 400)   



# precomputes template
shifterTemplate = makeGenShift()

# gets all valid a and b combinations
allAs = it.product(ALPHABET[1:], repeat = 2)
allBs = it.product(ALPHABET, repeat = bNums)

# This precomputes all windows
windows = it.product(ALPHABET, repeat = WINDOWSIZE)
allWindows = []
for window in windows:
    temp = np.ones((1,WINDOWSIZE+1))
    temp[0,:-1] = window
    allWindows.append(temp)


cycles = []
# actual main function
for a in allAs:
    for b in allBs:
        newShifter = np.copy(shifterTemplate)
        c = calcC(a[1],b)
        row = list(a)
        row.insert(1,c)
        row[1:1] = b
        newShifter[-2] = row
        # above generates possible shifter matrix, validated for A = {0,1} w = 3

        if VERBOSE:
            print("Shifter used")
            print(newShifter)

        cycleLength = checkCycle(allWindows[5][0],newShifter)
        if VERBOSE:
            print("Cycle length")
            print(cycleLength)
            print(MAXSIZE)
        if cycleLength%MAXSIZE == 0:
            print("we're good")
        cycles.append(cycleLength)

plt.hist(cycles)
plt.title(f"Cycles found for 0 window with {MAXSIZE} options")
plt.show()
